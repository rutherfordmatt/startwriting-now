<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Start Writing Now - 3 minute journal</title>
    
    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="msapplication-TileColor" content="#2d3748">
    <meta name="theme-color" content="#2d3748">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C841TYRSY9"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C841TYRSY9');
    </script>
    
    <!-- External CSS Files -->
    <link rel="stylesheet" href="assets/css/main.css">
    <link rel="stylesheet" href="assets/css/components.css">
    <link rel="stylesheet" href="assets/css/themes.css">
</head>
<body>
    <div class="container">
        <div class="container-inner">
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="Toggle light mode">‚òÄÔ∏è</button>
            
            <div class="header">
                <div class="logo">Start Writing...</div>
                <div class="streak-display" id="streakDisplay">Start your writing streak!</div>
            </div>

            <!-- View Toggle -->
            <div class="view-toggle" role="tablist" aria-label="View selection">
                <button class="view-btn active" onclick="showWriteView()" role="tab" aria-selected="true" aria-controls="writeView">Write</button>
                <button class="view-btn" onclick="showHistoryView()" role="tab" aria-selected="false" aria-controls="historyView">History</button>
            </div>

            <!-- Views Container -->
            <div class="views-container">
                <!-- WRITING VIEW (existing functionality) -->
                <div id="writeView">
                    <div class="prompt-section">
                        <div class="smart-toggle-section">
                            <div class="smart-toggle">
                                <div class="toggle-option active" data-mode="personal">Personal</div>
                                <div class="toggle-option" data-mode="career">Career</div>
                            </div>
                            <button class="new-prompt-btn" onclick="newPrompt()">New</button>
                        </div>
                        <div class="prompt-label">Smart Prompt</div>
                        <div class="prompt-text" id="currentPrompt">Loading your writing prompt...</div>
                    </div>

                    <div class="timer-section">
                        <div class="timer-display" id="timerDisplay" aria-live="polite" aria-label="Writing timer">3:00</div>
                        <div class="timer-controls">
                            <button class="btn btn-secondary" id="pauseBtn" onclick="pauseTimer()" style="visibility: hidden;" aria-label="Pause writing timer">Pause</button>
                        </div>
                    </div>

                    <div class="writing-area">
                        <textarea 
                            class="writing-textarea" 
                            id="writingArea" 
                            placeholder="Start writing..."
                            aria-label="Writing area for journal entry"
                            aria-describedby="wordCount"
                        ></textarea>
                        <div class="word-count" id="wordCount" aria-live="polite">0 words</div>
                    </div>

                    <div class="actions" role="group" aria-label="Entry actions">
                        <button class="btn btn-copy" id="copyBtn" onclick="copyToClipboard()" aria-describedby="copyHelp">Copy</button>
                        <button class="btn btn-save" id="saveBtn" onclick="saveEntry()" aria-describedby="saveHelp">Download</button>
                        <div id="copyHelp" class="sr-only">Copies your journal entry to clipboard for easy sharing</div>
                        <div id="saveHelp" class="sr-only">Downloads your journal entry as a text file</div>
                    </div>
                </div>

                <!-- HISTORY VIEW (new functionality) -->
                <div id="historyView" class="hidden">
                    <div class="history-section">
                        <div class="history-header">
                            <input type="text" class="history-search" id="historySearch" placeholder="Search your entries..." onkeyup="filterEntries()">
                            <div class="history-stats" id="historyStats">0 entries</div>
                            <div class="history-controls">
                                <button class="btn-export-all" onclick="exportAllEntries()">üì• Export All</button>
                                <button class="btn-clear-history" onclick="clearAllHistory()">üóëÔ∏è Clear All</button>
                            </div>
                        </div>
                        <div class="entries-container" id="entriesContainer">
                            <div class="no-entries">No entries yet. Start writing to see your history!</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="footer">
                <div class="footer-content">
                    <div style="font-style: italic; color: #8b949e; font-size: 0.85em;">Built with curiosity and launched with hope by <a href="https://mattrutherford.co.uk" target="_blank" class="footer-link">Matt Rutherford</a></div>
                    <div style="display: flex; gap: 16px; align-items: center;">
                        <a href="#about" class="footer-link" onclick="showAbout()">About</a>
                        <a href="mailto:feedback@mattrutherford.co.uk?subject=Start Writing Now - Feedback&body=Hi Matt,%0D%0A%0D%0AI tried your micro-journaling app and wanted to share some thoughts:%0D%0A%0D%0A" class="footer-link">Feedback</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hidden Netlify form for email collection -->
        <form name="newsletter-signup" method="POST" data-netlify="true" style="display:none;">
            <input type="email" name="email">
            <input type="text" name="source">
            <input type="text" name="entry_preview">
        </form>
    </div>

    <script>
        // External prompts data
        let externalPrompts = null;
        let promptsLoaded = false;

        // Fallback prompts (embedded for offline use)
        const fallbackPrompts = {
            life: [
                "What's one thing that made you smile today?",
                "Describe a moment when you felt completely at peace.",
                "What's something you're grateful for right now?",
                "If you could tell your past self one thing, what would it be?",
                "What's a small win you had recently?",
                "Describe your ideal Sunday morning.",
                "What's something new you learned this week?",
                "How do you want to feel by the end of today?",
                "What's a challenge you're facing, and how might you approach it?",
                "Describe a person who has positively impacted your life.",
                "What's something you're looking forward to?",
                "How has your perspective on something changed recently?",
                "What would you do if you knew you couldn't fail?",
                "What's a habit you'd like to develop?",
                "How do you show kindness to yourself?",
                "What's something that always makes you laugh?",
                "Describe a place where you feel most like yourself.",
                "What's the best advice you've ever received?",
                "How do you like to celebrate small victories?",
                "What's something you're curious about right now?"
            ],
            career: [
                "What's the most valuable skill you've developed this year?",
                "Describe a project you're proud of and why.",
                "What's a professional challenge you're currently navigating?",
                "How do you define success in your career?",
                "What's something you want to learn to advance professionally?",
                "Describe your ideal work environment.",
                "What's a piece of feedback that changed how you work?",
                "How do you maintain work-life balance?",
                "What's a professional relationship that has been meaningful to you?",
                "Describe a time when you had to step outside your comfort zone at work."
            ]
        };

        // Current state
        let currentMode = 'personal'; // personal or professional
        let lastUsedPrompts = [];

        // Timer variables
        let timeLeft = 180; // 3 minutes in seconds
        let timerInterval = null;
        let isRunning = false;

        // View state
        let currentView = 'write';

        // Load external prompts with fallback
        async function loadExternalPrompts() {
            try {
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
                
                const response = await fetch('./assets/data/prompts.json', {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    externalPrompts = await response.json();
                    
                    // Validate prompt structure
                    if (!externalPrompts.prompts || 
                        !externalPrompts.prompts.life || 
                        !externalPrompts.prompts.career) {
                        throw new Error('Invalid prompt data structure');
                    }
                    
                    promptsLoaded = true;
                    console.log('External prompts loaded successfully');
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.warn('Failed to load external prompts:', error.message);
                externalPrompts = { prompts: fallbackPrompts };
                promptsLoaded = true;
                
                // Store failure for later retry if needed
                localStorage.setItem('lastPromptLoadError', JSON.stringify({
                    error: error.message,
                    timestamp: Date.now()
                }));
            }
        }

        // Get prompts with fallback
        function getPrompts() {
            return externalPrompts ? externalPrompts.prompts : fallbackPrompts;
        }

        // Get time-aware prompt category
        function getTimeCategory() {
            const now = new Date();
            const hour = now.getHours();
            const day = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
            
            // Morning/Evening
            if (hour >= 5 && hour < 12) return 'morning';
            if (hour >= 18 || hour < 5) return 'evening';
            
            // Day of week
            if (day === 1) return 'monday'; // Monday
            if (day === 5) return 'friday'; // Friday
            if (day === 0 || day === 6) return 'weekend'; // Weekend
            
            return null;
        }

        // Get seasonal prompts
        function getSeasonalPrompts() {
            const prompts = getPrompts();
            if (prompts.seasonal && prompts.seasonal.current) {
                return prompts.seasonal[prompts.seasonal.current] || [];
            }
            return [];
        }

        // Avoid recently used prompts
        function filterRecentPrompts(promptArray) {
            if (lastUsedPrompts.length === 0) return promptArray;
            
            const filtered = promptArray.filter(prompt => !lastUsedPrompts.includes(prompt));
            return filtered.length > 0 ? filtered : promptArray;
        }

        // Track used prompts
        function trackUsedPrompt(prompt) {
            lastUsedPrompts.unshift(prompt);
            // Keep only last 10 prompts to avoid
            if (lastUsedPrompts.length > 10) {
                lastUsedPrompts = lastUsedPrompts.slice(0, 10);
            }
            localStorage.setItem('recentPrompts', JSON.stringify(lastUsedPrompts));
        }

        // Load recent prompts from storage
        function loadRecentPrompts() {
            const stored = localStorage.getItem('recentPrompts');
            if (stored) {
                lastUsedPrompts = JSON.parse(stored);
            }
        }

        // Set mode (personal/career)
        function setMode(mode) {
            currentMode = mode === 'career' ? 'professional' : 'personal';
            
            // Update UI
            document.querySelectorAll('.toggle-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // Get new smart prompt
            displaySmartPrompt();
        }

        // Ultra-smart prompt selection
        function displaySmartPrompt() {
            if (!promptsLoaded) {
                document.getElementById('currentPrompt').textContent = 'Loading prompts...';
                return;
            }

            const prompts = getPrompts();
            let promptArray = [];
            
            // Step 1: Get base prompts based on mode
            if (currentMode === 'professional') {
                promptArray = [...(prompts.career || fallbackPrompts.career)];
            } else {
                promptArray = [...(prompts.life || fallbackPrompts.life)];
            }

            // Step 2: Add time-aware intelligence
            const timeCategory = getTimeCategory();
            if (timeCategory && prompts.timeAware && prompts.timeAware[timeCategory]) {
                // Mix in 30% time-relevant prompts
                const timePrompts = prompts.timeAware[timeCategory];
                const mixCount = Math.floor(timePrompts.length * 0.3);
                promptArray = [...promptArray, ...timePrompts.slice(0, mixCount)];
            }

            // Step 3: Add mood-aware intelligence based on time and mode
            const currentHour = new Date().getHours();
            let smartMoodPrompts = [];
            
            if (currentMode === 'personal') {
                if (currentHour >= 18 || currentHour < 6) {
                    // Evening/night - reflective and grateful prompts
                    smartMoodPrompts = [
                        ...(prompts.moods?.reflective || []).slice(0, 3),
                        ...(prompts.moods?.grateful || []).slice(0, 3)
                    ];
                } else if (currentHour >= 6 && currentHour < 12) {
                    // Morning - energized and creative prompts
                    smartMoodPrompts = [
                        ...(prompts.moods?.energized || []).slice(0, 3),
                        ...(prompts.moods?.creative || []).slice(0, 2)
                    ];
                } else {
                    // Afternoon - mix of reflective and creative
                    smartMoodPrompts = [
                        ...(prompts.moods?.reflective || []).slice(0, 2),
                        ...(prompts.moods?.creative || []).slice(0, 2)
                    ];
                }
            } else {
                // Professional mode - always energized and focused
                smartMoodPrompts = [
                    ...(prompts.moods?.energized || []).slice(0, 3)
                ];
                
                // Add struggling support prompts on Mondays
                const today = new Date().getDay();
                if (today === 1) { // Monday
                    smartMoodPrompts = [
                        ...smartMoodPrompts,
                        ...(prompts.moods?.struggling || []).slice(0, 2)
                    ];
                }
            }
            
            promptArray = [...promptArray, ...smartMoodPrompts];

            // Step 4: Add seasonal intelligence
            const seasonalPrompts = getSeasonalPrompts();
            if (seasonalPrompts.length > 0) {
                promptArray = [...promptArray, ...seasonalPrompts.slice(0, 3)];
            }

            // Step 5: Filter out recently used prompts
            promptArray = filterRecentPrompts(promptArray);

            // Step 6: Final fallback
            if (promptArray.length === 0) {
                promptArray = currentMode === 'professional' ? 
                    fallbackPrompts.career : fallbackPrompts.life;
            }

            // Select and display prompt
            const randomIndex = Math.floor(Math.random() * promptArray.length);
            const selectedPrompt = promptArray[randomIndex];
            
            document.getElementById('currentPrompt').textContent = selectedPrompt;
            trackUsedPrompt(selectedPrompt);
        }

        // Initialize smart toggle
        function initSmartToggle() {
            document.querySelectorAll('.toggle-option').forEach(option => {
                option.addEventListener('click', function() {
                    const mode = this.getAttribute('data-mode');
                    setMode(mode);
                });
            });
            
            // Set personal as default
            setMode('personal');
        }

        // Initialize the app
        async function initApp() {
            // Load external prompts first
            await loadExternalPrompts();
            loadRecentPrompts();
            
            // Initialize UI
            initSmartToggle();
            displaySmartPrompt();
            updateWordCount();
            updateStreakDisplay();
            updateHistoryDisplay();
            
            // Set dark mode as default, but respect user preference if they've toggled before
            const savedDarkMode = localStorage.getItem('darkMode');
            if (savedDarkMode === null) {
                // First visit - default to dark mode
                document.body.classList.add('dark-mode');
                localStorage.setItem('darkMode', 'true');
            } else if (savedDarkMode === 'true') {
                document.body.classList.add('dark-mode');
            }
            updateDarkModeIcon();
            
            // Add textarea event listener for word count and auto-start timer
            const textarea = document.getElementById('writingArea');
            textarea.addEventListener('input', function() {
                updateWordCount();
                // Auto-start timer when user starts typing
                if (!isRunning && textarea.value.trim().length > 0 && timeLeft === 180) {
                    startTimer();
                }
            });
        }

        // NEW ENTRY HISTORY FUNCTIONS
        
        function getEntries() {
            const entries = localStorage.getItem('writingEntries');
            return entries ? JSON.parse(entries) : [];
        }

        function saveEntryToHistory(prompt, text, wordCount) {
            const entries = getEntries();
            const entry = {
                id: Date.now(),
                date: new Date().toISOString(),
                prompt: prompt,
                text: text,
                wordCount: wordCount,
                mode: currentMode
            };
            
            entries.unshift(entry); // Add to beginning of array
            localStorage.setItem('writingEntries', JSON.stringify(entries));
            updateHistoryDisplay();
        }

        function showWriteView() {
            currentView = 'write';
            document.getElementById('writeView').classList.remove('hidden');
            document.getElementById('historyView').classList.add('hidden');
            
            // Update view buttons and ARIA states
            const viewButtons = document.querySelectorAll('.view-btn');
            viewButtons.forEach((btn, index) => {
                btn.classList.remove('active');
                btn.setAttribute('aria-selected', 'false');
            });
            
            viewButtons[0].classList.add('active');
            viewButtons[0].setAttribute('aria-selected', 'true');
        }

        function showHistoryView() {
            currentView = 'history';
            document.getElementById('writeView').classList.add('hidden');
            document.getElementById('historyView').classList.remove('hidden');
            
            // Update view buttons and ARIA states
            const viewButtons = document.querySelectorAll('.view-btn');
            viewButtons.forEach((btn, index) => {
                btn.classList.remove('active');
                btn.setAttribute('aria-selected', 'false');
            });
            
            viewButtons[1].classList.add('active');
            viewButtons[1].setAttribute('aria-selected', 'true');
            
            updateHistoryDisplay();
        }

        function updateHistoryDisplay() {
            const entries = getEntries();
            const container = document.getElementById('entriesContainer');
            const stats = document.getElementById('historyStats');
            
            // Performance optimization: check if entries have changed
            const entriesHash = JSON.stringify(entries.map(e => ({ id: e.id, date: e.date })));
            if (lastRenderedEntries === entriesHash && container.children.length > 0) {
                return; // No need to re-render
            }
            lastRenderedEntries = entriesHash;
            
            // Update stats
            const totalWords = entries.reduce((sum, entry) => sum + entry.wordCount, 0);
            stats.textContent = `${entries.length} entries ‚Ä¢ ${totalWords} total words`;
            
            if (entries.length === 0) {
                container.innerHTML = '<div class="no-entries">No entries yet. Start writing to see your history!</div>';
                return;
            }

            // Generate entries HTML with better error handling
            const entriesHTML = entries.map(entry => {
                try {
                    const date = new Date(entry.date);
                    
                    // Validate date
                    if (isNaN(date.getTime())) {
                        console.warn('Invalid date for entry:', entry.id);
                        return ''; // Skip invalid entries
                    }
                    
                    const formattedDate = date.toLocaleDateString('en-US', { 
                        weekday: 'short', 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    // Safely truncate text
                    const safeText = (entry.text || '').toString();
                    const preview = safeText.length > 200 ? 
                        safeText.substring(0, 200) + '...' : safeText;
                    
                    // Escape HTML to prevent XSS
                    const escapeHtml = (text) => {
                        const div = document.createElement('div');
                        div.textContent = text;
                        return div.innerHTML;
                    };
                    
                    const modeEmoji = {
                        'personal': 'üí≠',
                        'professional': 'üíº'
                    };
                    
                    return `
                        <div class="entry-item" data-entry-id="${entry.id}">
                            <div class="entry-header">
                                <div class="entry-date">${formattedDate}</div>
                                <div class="entry-meta">
                                    <span>${entry.wordCount || 0} words</span>
                                    ${entry.mode ? `<span>${modeEmoji[entry.mode] || 'üí≠'} ${entry.mode}</span>` : 
                                      entry.category ? `<span>${entry.category}</span>` : '<span>personal</span>'}
                                </div>
                            </div>
                            <div class="entry-prompt">${escapeHtml(entry.prompt || 'No prompt')}</div>
                            <div class="entry-text">${escapeHtml(preview)}</div>
                            <div class="entry-actions">
                                <button class="btn-entry-action" onclick="copyEntry('${entry.id}')">Copy</button>
                                <button class="btn-entry-action" onclick="downloadEntry('${entry.id}')">Download</button>
                                <button class="btn-entry-action" onclick="deleteEntry('${entry.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                } catch (error) {
                    console.error('Error rendering entry:', entry.id, error);
                    return ''; // Skip problematic entries
                }
            }).filter(html => html).join(''); // Filter out empty entries
            
            container.innerHTML = entriesHTML;
        }

        // Performance optimization variables
        let searchTimeout = null;
        let lastRenderedEntries = null;

        function filterEntries() {
            // Debounce search to avoid excessive filtering
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                performSearch();
            }, 300); // 300ms delay
        }

        function performSearch() {
            const searchTerm = document.getElementById('historySearch').value.toLowerCase();
            const entries = document.querySelectorAll('.entry-item');
            let visibleCount = 0;
            
            entries.forEach(entry => {
                const text = entry.textContent.toLowerCase();
                const isVisible = text.includes(searchTerm);
                entry.style.display = isVisible ? 'block' : 'none';
                if (isVisible) visibleCount++;
            });
            
            // Update stats to show filtered results
            if (searchTerm) {
                const totalEntries = entries.length;
                document.getElementById('historyStats').textContent = 
                    `${visibleCount} of ${totalEntries} entries shown`;
            } else {
                // Reset to original stats
                const allEntries = getEntries();
                const totalWords = allEntries.reduce((sum, entry) => sum + entry.wordCount, 0);
                document.getElementById('historyStats').textContent = 
                    `${allEntries.length} entries ‚Ä¢ ${totalWords} total words`;
            }
        }

        function copyEntry(entryId) {
            const entries = getEntries();
            const entry = entries.find(e => e.id == entryId);
            if (!entry) return;
            
            const timestamp = new Date(entry.date).toLocaleString();
            const formattedEntry = `Start Writing Now - Journal Entry
Date: ${timestamp}
Prompt: ${entry.prompt}

${entry.text}

---
startwriting.now`;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(formattedEntry).then(() => {
                    alert('Entry copied to clipboard! üìã');
                });
            } else {
                fallbackCopyToClipboard(formattedEntry, entry.wordCount);
            }
        }

        function downloadEntry(entryId) {
            const entries = getEntries();
            const entry = entries.find(e => e.id == entryId);
            if (!entry) return;
            
            const timestamp = new Date(entry.date).toLocaleString();
            const formattedEntry = `Start Writing Now - Journal Entry
Date: ${timestamp}
Prompt: ${entry.prompt}

${entry.text}

---
startwriting.now
`;
            
            const blob = new Blob([formattedEntry], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `journal-entry-${new Date(entry.date).toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function deleteEntry(entryId) {
            if (!confirm('Are you sure you want to delete this entry? This cannot be undone.')) {
                return;
            }
            
            const entries = getEntries();
            const filteredEntries = entries.filter(e => e.id != entryId);
            localStorage.setItem('writingEntries', JSON.stringify(filteredEntries));
            updateHistoryDisplay();
        }

        function exportAllEntries() {
            const entries = getEntries();
            if (entries.length === 0) {
                alert('No entries to export!');
                return;
            }
            
            const allEntries = entries.map(entry => {
                const timestamp = new Date(entry.date).toLocaleString();
                return `Start Writing Now - Journal Entry
Date: ${timestamp}
Prompt: ${entry.prompt}

${entry.text}

---`;
            }).join('\n\n');
            
            const finalContent = `${allEntries}

Complete Journal Export from startwriting.now
Total Entries: ${entries.length}
Total Words: ${entries.reduce((sum, entry) => sum + entry.wordCount, 0)}
Exported: ${new Date().toLocaleString()}`;
            
            const blob = new Blob([finalContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `all-journal-entries-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(`Exported ${entries.length} entries! üì•`);
        }

        function clearAllHistory() {
            if (!confirm('Are you sure you want to delete ALL entries? This cannot be undone.')) {
                return;
            }
            
            if (!confirm('This will permanently delete all your writing history. Are you absolutely sure?')) {
                return;
            }
            
            localStorage.removeItem('writingEntries');
            updateHistoryDisplay();
            alert('All entries have been deleted.');
        }

        // EXISTING FUNCTIONS (modified to save to history)

        function startTimer() {
            if (!isRunning) {
                isRunning = true;
                document.getElementById('pauseBtn').style.visibility = 'visible';
                
                timerInterval = setInterval(() => {
                    timeLeft--;
                    updateTimerDisplay();
                    
                    if (timeLeft <= 0) {
                        finishTimer();
                    }
                }, 1000);
            }
        }

        function pauseTimer() {
            if (isRunning) {
                isRunning = false;
                clearInterval(timerInterval);
                document.getElementById('pauseBtn').style.visibility = 'hidden';
            }
        }

        function resetTimer() {
            isRunning = false;
            clearInterval(timerInterval);
            timeLeft = 180; // Fixed: 3 minutes, not 2
            updateTimerDisplay();
            document.getElementById('pauseBtn').style.visibility = 'hidden';
            document.getElementById('timerDisplay').classList.remove('timer-finished', 'pulse');
        }

        function finishTimer() {
            isRunning = false;
            clearInterval(timerInterval);
            timeLeft = 0;
            updateTimerDisplay();
            document.getElementById('pauseBtn').style.visibility = 'hidden';
            document.getElementById('timerDisplay').classList.add('timer-finished', 'pulse');
            
            // Play chime sound
            playChime();
            
            // Celebration message
            setTimeout(() => {
                alert('Great job! You completed your 3-minute writing session. üéâ');
            }, 500);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timerDisplay').textContent = display;
        }

        function updateWordCount() {
            const text = document.getElementById('writingArea').value;
            const words = text.trim().split(/\s+/).filter(word => word.length > 0);
            document.getElementById('wordCount').textContent = `${words.length} words`;
        }

        function copyToClipboard() {
            const prompt = document.getElementById('currentPrompt').textContent;
            const entry = document.getElementById('writingArea').value;
            
            if (entry.trim().length === 0) {
                alert('Please write something before copying!');
                return;
            }

            // Check if entry is substantial enough for streak (minimum 25 words)
            const words = entry.trim().split(/\s+/).filter(word => word.length > 0);
            if (words.length >= 25) {
                updateStreak();
                // Save to history
                saveEntryToHistory(prompt, entry, words.length);
            }
            
            // Create formatted text for clipboard
            const timestamp = new Date().toLocaleString();
            const formattedEntry = `Start Writing Now - Journal Entry
Date: ${timestamp}
Prompt: ${prompt}

${entry}

---
startwriting.now`;
            
            // Copy to clipboard
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(formattedEntry).then(() => {
                    const message = words.length >= 25 ? 
                        'Entry copied to clipboard! üìã' : 
                        'Entry copied to clipboard! Write 25+ words next time to count toward your streak. üìã';
                    alert(message);
                    
                    // Offer email backup after successful copy
                    setTimeout(() => {
                        offerEmailBackup(formattedEntry);
                    }, 1500);
                }).catch(err => {
                    // Fallback for older browsers
                    fallbackCopyToClipboard(formattedEntry, words.length);
                });
            } else {
                // Fallback for older browsers or non-secure contexts
                fallbackCopyToClipboard(formattedEntry, words.length);
            }
        }

        function fallbackCopyToClipboard(text, wordCount) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                const message = wordCount >= 25 ? 
                    'Entry copied to clipboard! üìã' : 
                    'Entry copied to clipboard! Write 25+ words next time to count toward your streak. üìã';
                alert(message);
                
                // Offer email backup after successful copy
                setTimeout(() => {
                    offerEmailBackup(text);
                }, 1500);
            } catch (err) {
                alert('Unable to copy to clipboard. Please try the download option instead.');
            }
            
            document.body.removeChild(textArea);
        }

        function newPrompt() {
            displaySmartPrompt();
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
            updateDarkModeIcon();
        }

        function updateDarkModeIcon() {
            const button = document.querySelector('.dark-mode-toggle');
            const isDarkMode = document.body.classList.contains('dark-mode');
            button.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô';
        }

        function playChime() {
            try {
                // Check if AudioContext is supported
                if (!window.AudioContext && !window.webkitAudioContext) {
                    console.warn('Web Audio API not supported');
                    return;
                }
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Handle suspended context (common in modern browsers)
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        createChimeNotes(audioContext);
                    }).catch(err => {
                        console.warn('Could not resume audio context:', err);
                    });
                } else {
                    createChimeNotes(audioContext);
                }
                
            } catch (error) {
                console.warn('Audio playback failed:', error);
                // Fallback: Could add visual indication instead
            }
        }

        function createChimeNotes(audioContext) {
            // Create three notes for a pleasant chime
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
            
            frequencies.forEach((freq, index) => {
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'sine';
                    
                    // Set volume envelope for a soft chime
                    const startTime = audioContext.currentTime + index * 0.2;
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 1.5);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + 1.5);
                } catch (noteError) {
                    console.warn(`Failed to create note ${freq}Hz:`, noteError);
                }
            });
        }

        function saveEntry() {
            const prompt = document.getElementById('currentPrompt').textContent;
            const entry = document.getElementById('writingArea').value;
            
            if (entry.trim().length === 0) {
                alert('Please write something before downloading!');
                return;
            }

            // Check if entry is substantial enough for streak (minimum 25 words)
            const words = entry.trim().split(/\s+/).filter(word => word.length > 0);
            if (words.length >= 25) {
                updateStreak();
                // Save to history
                saveEntryToHistory(prompt, entry, words.length);
            }
            
            // Create formatted text for download
            const timestamp = new Date().toLocaleString();
            const formattedEntry = `Start Writing Now - Journal Entry
Date: ${timestamp}
Prompt: ${prompt}

${entry}

---
startwriting.now
`;
            
            // Create and trigger download
            const blob = new Blob([formattedEntry], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `journal-entry-${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            const message = words.length >= 25 ? 
                'Your journal entry has been downloaded! üìù' : 
                'Your journal entry has been downloaded! Write 25+ words next time to count toward your streak. üìù';
            alert(message);
            
            // Offer email backup after successful download
            setTimeout(() => {
                offerEmailBackup(formattedEntry);
            }, 1500);
        }

        function showAbout() {
            alert(`About Start Writing

This is an intelligent micro-journaling app designed to help you capture your thoughts with the perfect prompts.

How it works:
‚Ä¢ Choose Personal or Professional writing mode
‚Ä¢ Get smart prompts that adapt to time of day and season
‚Ä¢ Start typing to begin the 3-minute timer
‚Ä¢ Write freely without worrying about structure
‚Ä¢ Your entries are automatically saved to your history

Smart Features:
‚Ä¢ Time-aware prompts (different for morning vs evening)
‚Ä¢ Intelligent prompt selection that avoids recent duplicates
‚Ä¢ Seasonal and contextual awareness
‚Ä¢ Full writing history with search and export
‚Ä¢ Works completely offline

The goal is to make writing a daily habit through short, focused sessions with perfectly matched prompts. No accounts needed - everything saves locally in your browser.

Perfect for daily reflection, gratitude practice, career planning, or creative expression.`);
        }
        function getStreakData() {
            const defaultData = {
                currentStreak: 0,
                longestStreak: 0,
                lastWriteDate: null,
                writingDays: []
            };
            
            const stored = localStorage.getItem('writingStreak');
            return stored ? JSON.parse(stored) : defaultData;
        }

        function saveStreakData(data) {
            localStorage.setItem('writingStreak', JSON.stringify(data));
        }

        function updateStreak() {
            const today = new Date().toISOString().split('T')[0];
            const streakData = getStreakData();
            
            // Don't count multiple entries on the same day
            if (streakData.writingDays.includes(today)) {
                return;
            }
            
            // Add today to writing days
            streakData.writingDays.push(today);
            streakData.lastWriteDate = today;
            
            // Calculate current streak
            const sortedDays = streakData.writingDays.sort();
            let currentStreak = 1;
            
            for (let i = sortedDays.length - 2; i >= 0; i--) {
                const currentDate = new Date(sortedDays[i + 1]);
                const previousDate = new Date(sortedDays[i]);
                const dayDiff = (currentDate - previousDate) / (1000 * 60 * 60 * 24);
                
                if (dayDiff === 1) {
                    currentStreak++;
                } else {
                    break;
                }
            }
            
            streakData.currentStreak = currentStreak;
            
            // Update longest streak
            if (currentStreak > streakData.longestStreak) {
                streakData.longestStreak = currentStreak;
            }
            
            saveStreakData(streakData);
            updateStreakDisplay();
            celebrateStreak(currentStreak);
        }

        function updateStreakDisplay() {
            const streakData = getStreakData();
            const display = document.getElementById('streakDisplay');
            
            if (streakData.currentStreak === 0) {
                display.textContent = 'Start your writing streak!';
            } else if (streakData.currentStreak === 1) {
                display.textContent = 'üî• Day 1 - Keep it going!';
            } else {
                display.textContent = `üî• ${streakData.currentStreak} day streak`;
                if (streakData.longestStreak > streakData.currentStreak) {
                    display.textContent += ` (Best: ${streakData.longestStreak})`;
                }
            }
        }

        function celebrateStreak(streak) {
            let message = '';
            
            if (streak === 1) {
                message = 'Great job starting your writing streak! üéâ';
            } else if (streak === 3) {
                message = 'Amazing! 3 days in a row! üî•';
            } else if (streak === 7) {
                message = 'Incredible! You\'ve written for a whole week! üåü';
                // Offer streak protection email after celebrating 7-day streak
                setTimeout(() => {
                    offerStreakProtection();
                }, 2000);
            } else if (streak === 14) {
                message = 'Two weeks of writing! You\'re building a real habit! üí™';
            } else if (streak === 30) {
                message = 'One month streak! You\'re a writing champion! üèÜ';
            } else if (streak % 10 === 0 && streak > 30) {
                message = `${streak} days of writing! Absolutely incredible! üéä`;
            }
            
            if (message) {
                setTimeout(() => alert(message), 1000);
            }
        }

        // Email collection functions
        function offerEmailBackup(entryText) {
            // Only offer if not previously declined
            if (localStorage.getItem('emailBackupDeclined') === 'true') {
                return;
            }
            
            // Don't offer too frequently
            const lastOffered = localStorage.getItem('lastEmailBackupOffer');
            const now = new Date().getTime();
            if (lastOffered && (now - parseInt(lastOffered)) < 7 * 24 * 60 * 60 * 1000) { // 7 days
                return;
            }
            
            if (confirm('üíå Want to email this entry to yourself?\n\n(You can also join my weekly newsletter for exclusive writing prompts)')) {
                // Open email client with entry
                const subject = 'My Writing Entry - ' + new Date().toDateString();
                const body = encodeURIComponent(entryText);
                window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
                
                // Ask for newsletter signup
                setTimeout(() => {
                    collectEmailForNewsletter('backup', entryText.substring(0, 100));
                }, 3000);
            } else {
                localStorage.setItem('emailBackupDeclined', 'true');
            }
            
            localStorage.setItem('lastEmailBackupOffer', now.toString());
        }

        function offerStreakProtection() {
            // Only offer once
            if (localStorage.getItem('streakEmailOffered') === 'true') {
                return;
            }
            
            if (confirm('üî• 7-day streak achieved! Want a gentle daily reminder to keep your streak alive?\n\n(I\'ll also send weekly writing prompts to help you grow)')) {
                collectEmailForNewsletter('streak', '7-day streak protection');
            }
            
            localStorage.setItem('streakEmailOffered', 'true');
        }

        function collectEmailForNewsletter(source, preview) {
            const email = prompt('Enter your email for ' + (source === 'backup' ? 'entry backup and ' : '') + 'weekly writing prompts:');
            
            if (email && email.includes('@')) {
                // Submit to Netlify form
                const formData = new FormData();
                formData.append('form-name', 'newsletter-signup');
                formData.append('email', email);
                formData.append('source', source);
                formData.append('entry_preview', preview);
                
                fetch('/', {
                    method: 'POST',
                    body: formData
                }).then(() => {
                    alert('‚úÖ Thanks! You\'ll receive weekly writing prompts and updates.');
                }).catch(() => {
                    alert('Thanks! You\'ll receive weekly writing prompts and updates.');
                });
            }
        }

        // Initialize the app when page loads
        window.addEventListener('load', initApp);
    </script>
</body>
</html>